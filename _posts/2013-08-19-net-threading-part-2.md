---
id: 49
title: .Net Threading Part 2
date: 2013-08-19T00:00:00+00:00
author: Jorden
layout: post
guid: http://www.fbombcode.com/title/.Net_Threading_Part_2
permalink: /2013/08/19/net-threading-part-2/
categories:
  - .net
tags:
  - .net
  - threading
---
 <p> So, my last article about threading was so popular, and since it is a big subject, I thought I would research Task Parallel Library. Tasks let you express threading in a very different way than what Object Oriented or Procedural programmer would be accustom to for threading. Let&#8217;s see why it resembles javascript promises. </p> <p> If you have been seeing the progression of C#, it is clear that Microsoft is making the language more functional, like F#. Anonymous Types, Anonymous Functions, Linq, Extension Methods are all examples of the functional ideas making their way to C#, and for the most part they work great. Threads are another thing that can make a huge developer productivity boost by programming in a more functional way. This is because if you keep your data very immutable, then you can thread really easily. This is where Task Parallel library comes it, as it is Microsoft&#8217;s way to help you program Threads simpler. </p> <p> <h2>Functions and Properties on Class Task</h2> <ol> <li>1) Start &#8211; This will start a Task</li> <li>2) ContinueWith &#8211; After a Task is completed, this will execute.</li> <li>3) WaitAll &#8211; Waits till all Tasks, in an array, are done.</li> <li>4) Wait &#8211; Waits for just that one Task to be done.</li> </ol> <h2>Other Stuff</h2> <ol> <li>1) CancellationToken &#8211; Used to tell all Tasks, that are given the token, that cancel was called on that thread.</li> <li>2) locks, Semaphore, mutex &#8211; These classes help keep Tasks, and Threads synchronized.</li> <li>3) Async and Await &#8211; Two new keywords to decorate functions to tell the compiler what can be threaded. </ol> </p> <p> Now that we have seen Task library and some of the other stuff to help thread with it, let&#8217;s check out a scenario: </p> <pre class="formatCode"> class Program { static readonly Semaphore semaphore = new Semaphore(Environment.ProcessorCount, Environment.ProcessorCount); static readonly ConcurrentDictionary<task,int> myCurrentTasks = new ConcurrentDictionary<task,int> (); static bool isExit; static void Main(string[] args) { int threadCount = 0; CancellationTokenSource cts = new CancellationTokenSource (); cts.Token.Register (() => {Console.WriteLine("Cancelling: "+myCurrentTasks.Keys.Count+" Threads!");}); DateTime start = DateTime.Now; Task.Factory.StartNew(() => { while (Console.ReadKey().Key != ConsoleKey.Q) ; isExit = true; }); while(true) { if (threadCount == int.MaxValue) { threadCount = 0; } semaphore.WaitOne(); Task task = new Task ( (state) => { Thread.CurrentThread.IsBackground = false; var doWork = new dodo (); doWork.work (cts.Token, state); semaphore.Release (); }, threadCount++, cts.Token); task.Start (); task.ContinueWith((theTask)=>{ int j = 0; myCurrentTasks.TryRemove(theTask, out j); theTask.Dispose(); }); myCurrentTasks.TryAdd( task, threadCount); int seconds = (DateTime.Now - start).Seconds; Console.WriteLine ("seconds: " + seconds); if (isExit) { cts.Cancel (); var tasks = myCurrentTasks.Keys.ToArray (); Task.WaitAll ( tasks.Where(p => p.Status != TaskStatus.Canceled).ToArray ()); Console.WriteLine("Cancelling Complete! This many threads: "+myCurrentTasks.Count); break; } } } } public class dodo { public void work(CancellationToken token, object state) { Console.WriteLine("Doing work at '{0}' state: '{1}'", DateTime.Now, state); Random r = new Random(); int counter = 0; int count = r.Next (6, 9); while (counter < count) { if (token.IsCancellationRequested) { Console.WriteLine("Cancelled work at '{0}' state: '{1}'", DateTime.Now, state); return; } Thread.Sleep ( 1000); counter++; } Console.WriteLine("DONE work at '{0}' state: '{1}'", DateTime.Now, state); } } </pre> <p> There is a bunch of stuff going on, so I will try to go over the good parts. Overall, the app is going to process a number of threads, equal to the <em>Environment.ProcessorCount</em>. This is to make sure we make the sweet amount of threads, which is generally one thread per core. Each Task processes work for 6 to 9 seconds. If the user presses <em>'q'</em>, then the Task uses <em>CancellationTokenSource</em> to cancel any working Tasks. While the Tasks are stopping, the <em>Task.WaitAll(tasks.Where(p => p.Status != TaskStatus.Canceled).ToArray());</em> will wait for any thread that is still "working" to stop. The tasks array in the wait all is populated with each Task, and is removed when we call <em>ContinueWith</em>. </p> <p> If you read my previous post <a href="/title/.Net_Threading">.Net Threading Part 1</a>, There I have code that is very similar to the code above. The difference in this code is that, I can control when my Tasks/Threads are done, or when they should be done. ThreadPool can only tell threads to stop processing, nothing more. We have gain much more control with Tasks. You will also note that the more control that you get has given you more callbacks to program. The coding looks very much like a callback scenario from javascript. </p> <p> While ThreadPool is something that other languages have, like Java, they do not have the new implementation of Tasks. Tasks allow you more control over threads and give developers cleaner code. Special thanks to Alex and Scott for giving me some more reading about .Net Threads. Tasks are something you want to use over the other threading libraries. </p>