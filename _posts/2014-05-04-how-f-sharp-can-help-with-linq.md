---
id: 32
title: How F Sharp Can Help With LINQ
date: 2014-05-04T00:00:00+00:00
author: Jorden
layout: post
guid: http://www.fbombcode.com/title/How_F_Sharp_Can_Help_With_LINQ
permalink: /2014/05/04/how-f-sharp-can-help-with-linq/
categories:
  - .net
tags:
  - .net
  - 'F#'
  - linq
---
 <p> I took a break from the web and decided to work on something different, like F#. What I didn&#8217;t realize is how awesome F# has helped me understand LINQ in C# and Vice Versa. </p> <p> I have read most of the blog, from the <a href="https://msmvps.com/blogs/jon\_skeet/archive/2011/03/18/edulinq-the-e-book.aspx">Edulinq</a> series. This gave me insight to what is happening in LINQ, it&#8217;s to crunch lists of data. This sounds like something that F# does well. </p> <p> Some of the structure threw me off of F#, like loops and if/else statements. But there are ways around this: </p> <h2> <a href="http://msdn.microsoft.com/en-us/library/dd547125.aspx">Pattern Matching</a> </h2> <p> In order to have a traditional switch statement, or if/else for that matter, you should look into pattern matching: </p> <pre class="formatCode"> match isDivisible with | true -> acc/item | false -> acc </pre> <p> This show how to switch between true and false. Pattern matching is more powerful than switch statements, however: </p> <pre> match list with | head -> (\* process one item \*) | tail -> (\* process the rest of the list \*) | \_ -> (\* oops something happened \*) </pre> <p> So for the simple example, this is matching pieces of a list. The first line you process the first item in the list, and the second line, you process the rest of the list. This pattern can help process a list super quickly. </p> <h2> Fold and Unfold </h2> <p> So now that you have your branching methods, how can you loop and generate data? This is where [1 .. n] comes in. If you need to generate data, you can use this, but what if you need to generate a more complex set of data? Use an unfold: </p> <pre class="formatCode"> Seq.unfold( fun(x) -> Some(x, x+1) ) 2 |> Seq.takeWhile (fun x -> x = 10) </pre> <p> The first line takes a function that generates a list from 2 to some number incrementing by 1. The second line stops generating numbers, once you get to 10. So after these 2 lines, it will generate an IEnumberable that will yield: [2,3,4,5,6,7,8,9,10]. It is important to note that this does not execute until you need to process the data later. Something we are fond of in LINQ with enumerables. </p> <p> So this generates a list, how can we condense a list into one thing, like a Sum? Use a fold: </p> <pre class="formatCode"> [1..10] |> Seq.fold(fun acc elem -> acc = acc + elem) 0 </pre> <p> While you could use the Sum function, fold can do the same thing, and more. Fold takes in a set, [1..10], a function, and a starting value. The function has a signature of 2 parameters, the accumlator and each element it will loop through. </p> <p> The neat thing with F# is that all Seq, or List or Array objects have these functions, more or less. All these functions do is loop through all the elements of a collection and execute the same function on each of the elements. The difference is what is returned from those values. </p> <h2>More useful list functions in F#</h2> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">Filter</h3> </div> <div class="panel-body"> Filter is like a where clause in SQL. It filters stuff, daaa! Takes: a list, and a function that takes an element and returns a bool Returns: a list of items that fit that criteria </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">Map</h3> </div> <div class="panel-body"> <p>Map executes a function on each item of an array. Note this may change the element</p> <p><strong>Takes:</strong> a list, and a function that executes on every item in the list</p> <p><strong>Returns:</strong> The modified list</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">Iter</h3> </div> <div class="panel-body"> <p>Much like Map, except it does not return a modified list, and is more for side effects.</p> <p><strong>Takes:</strong> a list, and a function that executes on every item in the list</p> <p><strong>Returns:</strong> unit, which basically means returns nothing (not null, it&#8217;s complicated)</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">nth</h3> </div> <div class="panel-body"> <p>Yes, there is a function called nth, which gives you that nth item, get it?</p> <p><strong>Takes:</strong> a list, and the index of the value you wanted</p> <p><strong>Returns:</strong> the element of that index. kinda like in c# array a[1] or elementAt</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">rev</h3> </div> <div class="panel-body"> <p>Reverses an list</p> <p><strong>Takes:</strong> a list</p> <p><strong>Returns:</strong> the reverse of the list</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">max</h3> </div> <div class="panel-body"> <p>Gets the max number</p> <p><strong>Takes:</strong> a list</p> <p><strong>Returns:</strong> the maximum value of the array</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">sum</h3> </div> <div class="panel-body"> <p>Gets the sum of an list</p> <p><strong>Takes:</strong> a list</p> <p><strong>Returns:</strong> The sum of all the values</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">append</h3> </div> <div class="panel-body"> <p>Smashes 2 arrays together</p> <p><strong>Takes:</strong> a list and another list</p> <p><strong>Returns:</strong> both lists put together</p> </div> </div> <div class="panel panel-info"> <div class="panel-heading"> <h3 class="panel-title">init</h3> </div> <div class="panel-body"> <p>Creates a sequence, in case the [1..n] method doesn&#8217;t work. And for int64, it doesn&#8217;t</p> <p><strong>Takes:</strong> The number you want to count up to and a function to generate for each index</p> <p><strong>Returns:</strong> a list</p> </div> </div> <p> These functions and techniques are the basics, and will help you write some F# that is useful. Not only that, I hope it helps give you a new perspective on LINQ, because they are basically the same thing. If you have an F#, or LINQ, function that is also useful, please throw them into the comments. </p>