---
id: 36
title: Rabbit MQ Topics and Pub Sub
date: 2014-02-09T00:00:00+00:00
author: Jorden
layout: post
guid: http://www.fbombcode.com/title/Rabbit_MQ_Topics_and_Pub_Sub
permalink: /2014/02/09/rabbit-mq-topics-and-pub-sub/
categories:
  - erlang
  - Message Queue
tags:
  - message queue
  - rabbit mq
---
 <p> So it has been a while since <a href="/title/Starting\_Rabbit\_MQ\_up\_for\_your\_Mac">part 1</a> and <a href="/title/Rabbit\_MQ\_Message\_Queues">part 2</a> of my Rabbit MQ series, but I definitely wanted to rap up my rabbling about Rabbit MQ and all the different configurations that could happen with the Message Queue. In this article, I will talk about how Topics, pub sub and routings work and what they are best at, when considering your architecture. </p> <p> The best part about this whole talk is the idea that this is how message queues work. Even if you do find yourself using a different message queue, the idea of queues, topics, pub sub and routings are still the main focus. Today, I plan to talk about the last topics (no pun intended) in this discussion: <a href="#pubsub">pub sub</a>, <a href="#routing">routings</a> and <a href="#topic">Topics</a>. </p> <h2 > <a id="pubsub">Pub Sub</a> </h2> <p> Pub sub is actually <strong>Publish/subscribe</strong> and in the rabbit mq space, you can find more information <a href="http://www.rabbitmq.com/tutorials/tutorial-three-python.html">here</a>. Think of this as the simplest approach to message broadcasting. </p> <p> Let&#8217;s say, I have a news feed that I want to send, I will give it a category, USA. Now, if I want to hear news for USA, I will create a USA queue. What I have to do, as a subscriber, is tell the exchange to fan out all messages, about USA, to my queue. Any messages about the other countries, will not reach this queue, so they must be listen to specifically. Also, any other people who want to listen to the USA, can, however, if no one is using the USA queue, it will simply disappear. This approach makes more sense for simple chat systems, games, and routing systems to other queues, like topics or routing. </p> <h2 > <a id="routing">Routing</a> </h2> <p> The problem with publish and subscribe is that the message disappears. What if you need a persistent messaging system? This is where <a href="http://www.rabbitmq.com/tutorials/tutorial-four-python.html">routing</a> come in. So, for example, what if have need of a logging system, where I can monitor errors, but the rest goes into the database, let&#8217;s say for history. Now, what I can do is set up 2 events, one error, and one All Logs. Both create a queue, and have an exchange, but unlike the previous pub sub model, those messages will be waiting until something processes those requests and &#8220;acknowledges&#8221; the message. The acknowledgment tells the queue to dump the message off of the queue. </p> <p> This makes perfect sense for a system that wants to process all messages, but only a certain event. This makes sense for routing messages, but does not have ANY flexibility in finer grain filtering. You could create 5 queues, but what if you need more types of filtering on the fly? This is where topics can help. </p> <h2 > <a id="topic">Topics</a> </h2> <p> For topics, I will be talking mostly from <a href="http://www.rabbitmq.com/tutorials/tutorial-five-python.html">this</a>. Topics provide ALL of the benefits that are above, so your message is persisted and you can add as much filtering as you want. From experience, this is what you typically want to use for any message broadcasting. Below is some code I wrote to demonstrate topics: </p> <pre class="formatCode"> //send a message public void Send<t>(T msg, string topic) where T : class { using (var channel = Connection.CreateModel()) { System.Xml.Serialization.XmlSerializer x = new System.Xml.Serialization.XmlSerializer(msg.GetType()); channel.ExchangeDeclare(QueueName, ExchangeType.Topic); TextWriter writer = new StringWriter(); x.Serialize(writer, msg); var body = Encoding.UTF8.GetBytes(writer.ToString()); IBasicProperties basicProperties = channel.CreateBasicProperties(); channel.BasicPublish(QueueName, topic, basicProperties, body); } } //listen for a message public class RabbitMQTopicReceiver : IMessageTopicReceiver { public IConnection Connection { get; private set; } public string QueueName { get; private set; } public string Topic { get; private set; } public bool IsStarted { get; private set; } private EventingBasicConsumer consumer; private IModel model; public IDictionary<string, string> MessageStringProperties { get; private set; } public RabbitMQTopicReceiver(IConnection connection, string queueName, string topic, IDictionary<string, string> messageStringProperties) { Connection = connection; QueueName = queueName; MessageStringProperties = messageStringProperties; Topic = topic; consumer = new EventingBasicConsumer(); IsStarted = false; } public RabbitMQTopicReceiver(IConnection connection, string queueName, string topic) { Connection = connection; QueueName = queueName; MessageStringProperties = null; Topic = topic; consumer = new EventingBasicConsumer(); IsStarted = false; } public event EventHandler<topicMessageEventArgs> MessageReceived; public void Start() { if (!IsStarted) { IsStarted = true; model = Connection.CreateModel(); consumer.Received += consumer\_Received; IDictionary<string, object> dict = null; if (MessageStringProperties != null) { MessageStringProperties.ToDictionary(k => k.Key, j => (object)j.Value); } model.ExchangeDeclare(QueueName, ExchangeType.Topic); var queueName = model.QueueDeclare(); model.QueueBind(queueName, QueueName, Topic, dict); model.BasicConsume(queueName, true,consumer); } } void consumer\_Received(IBasicConsumer sender, BasicDeliverEventArgs args) { var message = Encoding.UTF8.GetString(args.Body); int dots = message.Split('.').Length - 1; //sender.Model.BasicAck(args.DeliveryTag, false); var arg = new TopicMessageEventArgs(message); MessageReceived.Invoke(this, arg); } public void Stop() { if (IsStarted) { IsStarted = false; model.Close(); model.Dispose(); consumer.Received -= consumer\_Received; } } public void Dispose() { Stop(); } } </pre> <p> The important things to note are in the ExchangeDeclare function. It contains Topic, for creating a topic message queue. If you wanted to do Pub Sub, just change it to Fanout or if you want Routing, just change it to Direct. There may be some tweaks that you need to do, but thats about it. If you want to check out more on my example, you can go to my github page for this <a href="https://github.com/supermitsuba/MessageConsumer">code example</a>. </p>