---
id: 57
title: How to Write Better Unit Tests
date: 2013-06-01T00:00:00+00:00
author: Jorden
layout: post
guid: http://www.fbombcode.com/title/How_to_Write_Better_Unit_Tests
permalink: /2013/06/01/how-to-write-better-unit-tests/
categories:
  - .net
  - unit testing
tags:
  - .net
  - unit testing
---
 <p> When I first wrote unit tests, I thought that coding them was different than coding. Tests weren&#8217;t DRY, long and ugly, compared to regular code. But the problem with that is code is code, and ignoring your tests make it harder to understand and maintain. So, this blog post is about changing our thinking on how to write unit tests. </p> <p> First things first, there are some topics I am assuming you are familiar with in unit testing. These items are crucial to unit testing and if you don&#8217;t know them, take some time to read the links below: </p> <pre> Things to know for Unit Testing: 1)<a href="http://en.wikipedia.org/wiki/SOLID\_(object-oriented\_design)">Dependency Injection and SOLID</a> 2)<a href="http://www.hanselman.com/blog/ListOfNETDependencyInjectionContainersIOC.aspx">IOC container (optional)</a> 3)Some testing framework (<a href="http://en.wikipedia.org/wiki/Visual\_Studio\_Unit\_Testing\_Framework">MS Test</a>, <a href="http://xunit.codeplex.com/">XCode</a>, <a href="http://www.nunit.org/">NUnit</a>) 4)<a href="http://en.wikipedia.org/wiki/Don't\_repeat\_yourself">Dry</a> 5)Mocking Framework (<a href="https://code.google.com/p/moq/">Moq</a>, <a href="http://hibernatingrhinos.com/oss/rhino-mocks">Rhino Mocks</a>) </pre> <p> Now, have you seen unit tests like this? </p> <pre class="formatCode"> [TestClass] public class MyTestClass { [TestMethod] public void MyFirstTestRanSuccessfully() { var expected = true; var logger = new Mock<ilogger>(); var strategy = new Mock<istrategy>(); var data = new parameter() { value1="test" } logger.Setup(p => p.IsDebugEnabled).Returns(true); logger.Setup(p => p.Debug("logged")); var subject = new MyClass(); //The class I am testing subject.Logger = logger.Object; subject.Strategy = strategy.Object; var actual = subject.DoWork(data); Assert.AreNotEqual(expected, actual); strategy.Verify(p => p.DoStrategyWork, Times.Once(), "Did not call DoStrategyWork."); logger.Verify(p => p.IsDebugEnabled, Times.Once(), "Did not call IsDebugEnabled."); logger.Verify(p => p.Debug("logged"), Times.Once(), "Did not call Debug logger."); } } </pre> <p> The first issue with MyFirstTest is redundancy. If we were going to create a new test, we would copy the test data, at the beginning of the function, to another function. We don&#8217;t want to do that, so let&#8217;s create a TestInitialize. </p> <pre class="formatCode"> private Mock<ilogger> logger; private Mock<istrategy> strategy; [TestInitialize()] public void Initalize() { logger = new Mock<ilogger>(); strategy = new Mock<istrategy>(); var data = new parameter() { value1="test" } } [TestMethod] public void MyFirstTestRanSuccessfully() { var expected = true; logger.Setup(p => p.IsDebugEnabled).Returns(true); logger.Setup(p => p.Debug("logged")); var subject = new MyClass(); //The class I am testing subject.Logger = logger.Object; subject.Strategy = strategy.Object; var actual = subject.DoWork(data); Assert.AreNotEqual(expected, actual); strategy.Verify(p => p.DoStrategyWork, Times.Once(), "Did not call DoStrategyWork."); logger.Verify(p => p.IsDebugEnabled, Times.Once(), "Did not call IsDebugEnabled."); logger.Verify(p => p.Debug("logged"), Times.Once(), "Did not call Debug logger."); } </pre> <p> Here we are creating sample data we can use in every test. Don&#8217;t worry if you change this data in your test, as TestInitialize will reset for each new test. Also, you may see we have moved our mocks as well. This is because they are used over and over in the tests we are going to write for this class. <strong>So, put all the things that will be reused in TestInitialize to be more dry.</strong> </p> <p> After putting those tests togther, everything is looking leaner. But there still is a code smell, with unit tests specifically. The test isn&#8217;t testing one thing. The test is testing that it ran successfully AND that it logged values. <strong>In testing, you want to verify that one thing worked, so that it&#8217;s easy to maintain and read these tests.</strong> Let&#8217;s go ahead and refactor these tests. </p> <pre class="formatCode"> [TestClass] public class MyTestClass { [TestInitialize()] public void Initalize() { logger = new Mock<ilogger>(); strategy = new Mock<istrategy>(); var data = new parameter() { value1="test" } } [TestMethod] public void MyFirstTestLoggedAfterSuccess() { logger.Setup(p => p.IsDebugEnabled).Returns(true); logger.Setup(p => p.Debug("logged")); var subject = new MyClass(); //The class I am testing subject.Logger = logger.Object; subject.Strategy = strategy.Object; var actual = subject.DoWork(data); logger.Verify(p => p.IsDebugEnabled, Times.Once(), "Did not call IsDebugEnabled."); logger.Verify(p => p.Debug("logged"), Times.Once(), "Did not call Debug logger."); } [TestMethod] public void MyFirstTestRanSuccessfully() { var expected = true; var subject = new MyClass(); //The class I am testing subject.Logger = logger.Object; subject.Strategy = strategy.Object; var actual = subject.DoWork(data); Assert.AreNotEqual(expected, actual); strategy.Verify(p => p.DoStrategyWork, Times.Once(), "Did not call DoStrategyWork."); } } </pre> <p> Now, those tests look leaner and easier to read. If you notice that a unit test is growing large, it may be an indication that you are doing too much in that class. The rule I have seen is if you have any more dependencies than 3, then that class may be doing too much and needs to be refactored. More of a guideline than a rule. Also, don&#8217;t worry if you use different frameworks, as they should be very similar to above. Just remember: </p> <pre> 1)Put all the things that will be reused in TestInitialize to be more dry 2)In testing, you want to verify that one thing worked, so that it's easy to maintain and read these tests. 3)Name the tests to convey the tests being performed. 4)In a test class, keep like tests together in the same class, as they will be sharing the same TestInitialize. 5)If you have more than 3 dependencies, consider refactoring. </pre> <p> If you have some more tips, feel free to drop them in the comments section. </p>