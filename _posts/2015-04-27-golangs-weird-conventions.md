---
id: 12
title: 'GOLANGs weird conventions'
date: 2015-04-27T00:00:00+00:00
author: Jorden
layout: post
guid: 'http://www.fbombcode.com/title/GOLANG&#039;s_weird_conventions'
permalink: /2015/04/27/golangs-weird-conventions/
categories:
  - golang
tags:
  - golang
  - naming conventions
---
 <p> I have been writing Go programs for a little bit now and have found them not too bad to write. It is a C-style language that makes picking it up easy if you come from nodejs or C#. But, there are some weird nuances that you have to get use to if you do decide to pick up some Golang. </p> <p> Here goes the list: </p> <ol> <li> <div> <strong>Types, variables and functions that are lowercase are private.</strong> </div> <div> This is a big frustration when you first start, as there is no hint towards it. It&#8217;s hard to say I don&#8217;t like this rule, as it enforces style. This can be a good thing and is like getting a code linter for free. It is an issue when you are first building golang projects, as you do not know why you can not see a member. It would be nice to have the compiler hint towards the lower/uppercase issue. </div> </li> <li> <div> <strong>Types and Interfaces define functions differently than Java and C#.</strong> </div> <div> <p> I think golang is going back to the header and source file roots on this one. Basically, you define members and function signatures in your type signature. Then if you want to define the implimentation, you would make sure you add the type before the function name, like this example: </p> <pre class="formatCode"> package data import ( "io/ioutil" ) type IDataAccess interface { Save(key string, value string) Load(key string) string } type File\_access struct { FileLocation string } func (r File\_access) Save(key string, value string) { ioutil.WriteFile(r.FileLocation, []byte(value), 0777) } func (r File\_access) Load(key string) string { var value, \_ = ioutil.ReadFile(r.FileLocation) return string(value) } </pre> <p> This shows that the interface IDataAccess describes the method signatures, and File\_Access describes the fields of the struct. But in order to implement a File\_access struct, you need to add a (r File\_access) to tell golang that you are part of that struct. Weird. </p> </div> </li> <li> <div> <strong>What does (r * File\_access) that (r File\_access) doesnt.</strong> </div> <div> In the previous example, we could tie the function to a pointer to the struct or not. This is confusing, can I only call the function if it is a pointer or not? I think this is not needed, but maybe I&#8217;m wrong. It seemed to have no affect, so whatever. </div> </li> <li> <div> <strong>Creating a struct vs other stuff.</strong> </div> <div> If you want to create a struct, you can use this way: data.File\_access{FileLocation: &#8220;test.txt&#8221;} , but if you want to just call some functions, you can use this way: new(model.File_access). The difference is that one is just a bunch of functions in a namespace (package) and the other is a struct. This is confusing and leaves me wishing there was one way to create these. </div> </li> </ol> <p> While many of these items are complaints, I do enjoy the language. I just wish some of these language paradigms were cleaned up thats all. If you can explain some of these to me, leave a comment! </p>
