What is the Quicksort Implementation?,"        public static void sort(int[] a){
            sortImpl(a, 0, a.Length-1);
        }

        public static void sortImpl(int[] a, int left, int right){
            var i = left;
            var j = right;
            var pivot = a[(left+right)/2];

            while(i <= j){
                while(a[i] < pivot){
                    i++;
                }

                while(a[j] > pivot){
                    j--;
                }

                if(i <= j){
                    swap(a, i, j);
                    i++; 
                    j--;
                }

                if(left < j){
                    sortImpl(a, left, j);
                }

                if(i < right){
                    sortImpl(a, i, right);
                }
            }
        }

        private static void swap(int[] array, int index1, int index2){
            var tmp = array[index1];
            array[index1] = array[index2];
            array[index2] = tmp;
        }"
What is the Mergesort Implementation?,"        public static void sort(int[] a){
            var aux = new int[a.Length];
            sort(a, aux, 0, a.Length-1);
        }

        private static void sort(int[] a, int[] aux, int lo, int hi){
            if(hi <= lo) return;
            int mid = lo + (hi-lo) /2;
            sort(a, aux, lo, mid);
            sort(a, aux, mid+1, hi);
            merge(a, aux, lo, mid, hi);
        }

        private static void merge(int[] a, int[] aux, int lo, int mid, int hi){
            for(var k = lo; k <= hi; k++){
                aux[k] = a[k];
            }

            int i = lo, j = mid +1;
            for(int k = lo; k<= hi; k++){
                if(i > mid)               a[k] = aux[j++];
                else if(j > hi)           a[k] = aux[i++];
                else if(aux[j] < aux[i])  a[k] = aux[j++];
                else                      a[k] = aux[i++];
            }
        }"
What is the Heap/Heapsort Implementation? ,"public class MyHeap {
        List<int> _data;

        public MyHeap(int[] data){
            _data = new List<int>();
            _data.AddRange( data);
            build_max_heap();
        }

        public int Count(){
            return _data.Count;
        }

        public int extract_max(){
            var result = this.max();
            swap(0, _data.Count-1);
            _data.RemoveAt(_data.Count-1);
            max_heapify(0);
            return result;
        }

        public int max(){
            if(_data == null || _data.Count == 0) throw new Exception(""not enough elements"");

            return _data[0];
        }

        public void Insert(int x){
            _data.Add(x);
            IncreasingKey(_data.Count-1, x);
        }

        private void IncreasingKey(int index, int v){
            _data[index] = v;

            while(index > 0 && _data[index/2] < _data[index]){
                swap(index, index/2);
                index = index/2;
            }
        }

        private void build_max_heap(){
            for(var i = _data.Count/2; i >= 0; i--){
                max_heapify(i);
            }
        }

        private void max_heapify(int index){
            var l = index*2;
            var r = index*2+1;
            var largest = index;
            if(l < _data.Count && _data[l] > _data[largest]) {
                largest = l;
            }
            
            if(r < _data.Count && _data[r] > _data[largest]){
                largest = r;
            }
            
            if(largest != index){
                swap(index, largest);
                max_heapify(largest);
            }
        }

        public void swap(int index1, int index2){
            var tmp = _data[index1];
            _data[index1] = _data[index2];
            _data[index2] = tmp;
        }
    }"
What is Quicksorts complexity?,"Best O(nlogn)
avg O(nlogn)
worst O(n^2)
space O(logn)"
Why use mergesort vs quicksort vs heapsort?,"Quicksort - it is done in place, unstable and log(n) memory, worst case O(n^2) time
Mergesort - time O(n log(n)), space O(n), and is stable
Heapsort - not stable, but time O(n log(n)) and space O(1). You also have to maintain a heap"
What is Mergesort complexity?,"Best O(nlogn)
avg O(nlogn)
worst O(n logn)
space O(1)"
What is the complexity of using an Array?,"Here is the averge and worst case

Access O(1)  O(1)
Search O(n)  O(n)
Insert O(n)  O(n)
Delete O(n)  O(n)"
What is the complexity of BTree operations?,"Here is the averge and worst case

Access O(log n)  O(log n)
Search O(log n)  O(log n)
Insert   O(log n)  O(log n)
Delete  O(log n)  O(log n)"
What is the complexity of Binary Search Tree?,"Here is the averge and worst case

Access O(log n)  O(n)
Search O(log n)  O(n)
Insert   O(log n)  O(ln)
Delete  O(log n)  O(n)"
What is the complexity of Hash table?,"Here is the averge and worst case

Access O(1)  O(n)
Search O(1)  O(n)
Insert   O(1)  O(n)
Delete  O(1)  O(n)"
What is the complexity of Linked List?,"Here is the averge and worst case

Access O(n)  O(n)
Search O(n)  O(n)
Insert   O(1)  O(1)
Delete  O(1)  O(1)"
What is the complexity of Queue?,"Here is the averge and worst case

Access O(n)  O(n)
Search O(n)  O(n)
Insert   O(1)  O(1)
Delete  O(1)  O(1)"
What is the complexity of Stack?,"Here is the averge and worst case

Access O(n)  O(n)
Search O(n)  O(n)
Insert   O(1)  O(1)
Delete  O(1)  O(1)"
What is the complexity from worst to best?  i.e O(1) is best and O(n!) is the worst,"1
log(n)
n
n log(n)
n^2
2^n
n!"
How to do Breathe-First Search?,"public bool BFS (T value) {
    if(this.value == value) return true;

    var queue = new Queue<T>();

    if(left != null) queue.Enqueue(left);
    if(right != null) queue.Enqueue(right);

    while(!queue.IsEmpty()) {
        var node = queue.Dequeue();

        if(node.value == value) { return true; }
        else {
            if(node.left != null) queue.Enqueue(node.left);
            if(node.right != null) queue.Enqueue(node.right);            
        }
    }

    return false;
}

"
How to do Depth-First Search?,"public bool DFS(Tree<T> value) {
    bool result = false;
    if(value == this.value) { return true; }
    else {
        result = DFS(this.left);
        result = DFS(this.right) || result;
    }
    return result;
}
"
How to do Binary Search?,"public int search(int[] array, int search) {
    return searchImpl(array, search, 0, array.Length-1);
}

public int searchImpl(int[] array, int search, int start, int end){
    int mid = (start+end)/2;
    if(array[mid] == search) { return mid; }
    else {
        if(end-start <= 1) {
            return -1;
        }

        if(search > array[mid]) {
            return searchImpl(array, search, mid+1, end);
        }
        else {
            return searchImpl(array, search, 0, mid-1);
        }
    }
}"